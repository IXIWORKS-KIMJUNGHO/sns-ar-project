<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script type="module" src="https://ajax.googleapis.com/ajax/libs/model-viewer/3.3.0/model-viewer.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        /* Flutter UI 오버레이를 위한 간단한 설정 */
        /* 복잡한 차단 로직 제거함 */
        
        model-viewer {
            width: 100%;
            height: 100%;
        }

        /* iframe 기본 설정 - Flutter 오버레이 방식 사용 */
        
        /* 내장 AR 버튼 숨기기 */
        model-viewer::part(default-ar-button) {
            display: none !important;
        }

        /* AR 모드에서 기본 설정 사용 */
        
        /* AR 버튼과 배치 버튼 CSS 제거: Flutter UI에서 처리 */

        /* 터치 이동 시스템 CSS */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            100% { transform: scale(1.2); opacity: 0.9; }
        }

        .drag-feedback {
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        /* 터치 리플 효과 */
        .touch-ripple {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0, 122, 255, 0.3) 0%, rgba(0, 122, 255, 0) 70%);
            transform: scale(0);
            animation: ripple-effect 0.6s ease-out;
        }

        @keyframes ripple-effect {
            to {
                transform: scale(2);
                opacity: 0;
            }
        }

        /* 모델 터치 하이라이트 */
        .model-highlight {
            position: absolute;
            pointer-events: none;
            background: rgba(0, 122, 255, 0.2);
            border: 2px solid rgba(0, 122, 255, 0.6);
            border-radius: 50%;
            animation: highlight-pulse 0.4s ease-out;
        }

        @keyframes highlight-pulse {
            0% {
                transform: scale(0);
                opacity: 1;
            }
            100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }

        @keyframes liquidPulse {
            0% {
                box-shadow:
                    0 8px 32px rgba(0, 0, 0, 0.1),
                    0 2px 8px rgba(0, 122, 255, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.8),
                    0 0 0 0 rgba(0, 122, 255, 0.3);
            }
            50% {
                box-shadow:
                    0 8px 32px rgba(0, 0, 0, 0.1),
                    0 2px 8px rgba(0, 122, 255, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.8),
                    0 0 0 8px rgba(0, 122, 255, 0.2);
            }
            100% {
                box-shadow:
                    0 8px 32px rgba(0, 0, 0, 0.1),
                    0 2px 8px rgba(0, 122, 255, 0.2),
                    inset 0 1px 0 rgba(255, 255, 255, 0.8),
                    0 0 0 0 rgba(0, 122, 255, 0);
            }
        }

        /* 🎯 Ground Plane 시각화 */
        .ground-plane {
            position: absolute;
            border: 3px solid rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            transform: scale(0.8);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .ground-plane.show {
            opacity: 1;
            transform: scale(1);
        }

        .ground-plane::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            animation: plane-pulse 2s ease-in-out infinite;
        }

        @keyframes plane-pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.4);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(255, 255, 255, 0);
                transform: scale(1.05);
            }
        }
    </style>
</head>
<body>
    <model-viewer
        id="church-model"
        src="assets/models/church-model-01.glb"
        alt="온누리교회 3D 모델"
        camera-controls
        ar
        ar-modes="webxr scene-viewer quick-look">

        <!-- AR 버튼 제거: Flutter UI에서 처리 -->
    </model-viewer>

    <!-- 배치 버튼 제거: Flutter UI에서 처리 -->

    <!-- Flutter UI 오버레이 방식 사용 - 차단 div 불필요 -->
    
    <script>
        // 🔍 디버깅: 페이지 로드 확인
        console.log('🚀 model_viewer.html 스크립트 시작됨');

        // Model Viewer 초기화
        const viewer = document.querySelector('#church-model');
        console.log('🎯 Model Viewer 엘리먼트:', viewer);

        // placementButton 제거: Flutter UI에서 처리
        let currentScale = 1.0;
        let lastTouchDistance = 0;
        let isPlacementMode = false;
        let isModelPlaced = false;
        let isPlaneDetected = false;

        // 🎯 Ground Plane 변수
        let groundPlaneElement = null;
        let groundPlaneTimeout = null;

        // 모델 프리로딩 캐시
        const modelCache = new Map();
        const preloadedModels = [
            'assets/models/church-model-01.glb',
            'assets/models/church-model-02.glb',
            'assets/models/church-model-03.glb',
            'assets/models/church-model-04.glb',
            'assets/models/church-model-05.glb'
        ];

        // Flutter로 메시지 전송 헬퍼 함수
        function sendMessageToFlutter(type, data = {}) {
            const message = {
                type: type,
                ...data
            };

            console.log('📤 Flutter에 메시지 전송:', type);

            try {
                return window.parent.postMessage(message, '*');
            } catch (error) {
                console.error('❌ 메시지 전송 실패:', error);
                return null;
            }
        }

        // 모델 프리로딩 함수
        async function preloadModels() {
            console.log('🚀 모델 프리로딩 시작...');

            for (const modelUrl of preloadedModels) {
                try {
                    const response = await fetch(modelUrl);
                    if (response.ok) {
                        const blob = await response.blob();
                        const objectUrl = URL.createObjectURL(blob);
                        modelCache.set(modelUrl, objectUrl);
                        console.log(`✅ 프리로드 완료: ${modelUrl}`);
                    }
                } catch (error) {
                    console.warn(`⚠️ 프리로드 실패: ${modelUrl}`, error);
                }
            }

            console.log('🎉 모든 모델 프리로딩 완료!');
            sendMessageToFlutter('modelsPreloaded', { count: modelCache.size });
        }

        // 즉시 프리로딩 시작 (페이지 로드와 동시에)
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🚀 DOM 로드 완료, 즉시 프리로딩 시작');
            preloadModels();
        });

        // window load는 백업용
        window.addEventListener('load', () => {
            if (modelCache.size === 0) {
                console.log('🔄 window load에서 프리로딩 재시도');
                preloadModels();
            }
        });

        // 터치 리플 효과 생성
        function createTouchRipple(x, y) {
            const ripple = document.createElement('div');
            ripple.className = 'touch-ripple';
            ripple.style.left = (x - 25) + 'px';
            ripple.style.top = (y - 25) + 'px';
            ripple.style.width = '50px';
            ripple.style.height = '50px';

            document.body.appendChild(ripple);

            // 애니메이션 완료 후 제거
            setTimeout(() => {
                if (ripple.parentNode) {
                    ripple.parentNode.removeChild(ripple);
                }
            }, 600);
        }

        // 모델 터치 하이라이트 효과
        function createModelHighlight(x, y) {
            const highlight = document.createElement('div');
            highlight.className = 'model-highlight';
            highlight.style.left = (x - 20) + 'px';
            highlight.style.top = (y - 20) + 'px';
            highlight.style.width = '40px';
            highlight.style.height = '40px';

            document.body.appendChild(highlight);

            // 애니메이션 완료 후 제거
            setTimeout(() => {
                if (highlight.parentNode) {
                    highlight.parentNode.removeChild(highlight);
                }
            }, 400);
        }

        // 🎯 Ground Plane 시각화 함수
        function showGroundPlane() {
            console.log('🔍 showGroundPlane 함수 호출됨');
            console.log('🔍 viewer.arSession:', viewer.arSession);

            // AR 모드가 아니면 실행하지 않음 (일단 주석처리해서 테스트)
            // if (!viewer.arSession) {
            //     console.log('⚠️ AR 세션이 없어서 Ground Plane 표시 안함');
            //     return;
            // }

            // 기존 Ground Plane 제거
            hideGroundPlane();

            console.log('🎯 Ground Plane 표시 중...');

            try {
                // 모델의 바운딩 박스 계산
                const boundingBox = viewer.getBoundingClientRect();
                const modelBounds = viewer.model?.boundingBox;

                // Ground Plane 엘리먼트 생성 (CSS 클래스 없이 직접 스타일 적용)
                groundPlaneElement = document.createElement('div');

                // 모델 크기에 기반한 평면 크기 계산
                let planeWidth = 150;  // 기본 크기
                let planeHeight = 150;

                console.log('🔍 planeWidth:', planeWidth, 'planeHeight:', planeHeight);

                // 화면 중앙 하단에 배치 (AR에서 모델이 보통 중앙에 위치)
                const centerX = window.innerWidth / 2;
                const bottomY = window.innerHeight * 0.75; // 화면 하단 25% 지점

                console.log('🔍 centerX:', centerX, 'bottomY:', bottomY);

                // 직접 스타일 적용 (CSS 클래스 의존 제거)
                groundPlaneElement.style.position = 'absolute';
                groundPlaneElement.style.border = '3px solid rgba(255, 255, 255, 0.9)';
                groundPlaneElement.style.borderRadius = '8px';
                groundPlaneElement.style.background = 'rgba(255, 255, 255, 0.1)';
                groundPlaneElement.style.pointerEvents = 'none';
                groundPlaneElement.style.zIndex = '1000';
                groundPlaneElement.style.width = planeWidth + 'px';
                groundPlaneElement.style.height = planeHeight + 'px';
                groundPlaneElement.style.left = (centerX - planeWidth/2) + 'px';
                groundPlaneElement.style.top = (bottomY - planeHeight/2) + 'px';

                // DOM에 추가
                document.body.appendChild(groundPlaneElement);
                console.log('🔍 Ground Plane 엘리먼트가 DOM에 추가됨');

                // 즉시 표시 (CSS 애니메이션 제거)
                groundPlaneElement.style.opacity = '1';
                groundPlaneElement.style.display = 'block';

                // Flutter에 알림
                sendMessageToFlutter('groundPlaneShown', {
                    width: planeWidth,
                    height: planeHeight,
                    x: centerX,
                    y: bottomY
                });

                // 3초 후 자동 숨김
                groundPlaneTimeout = setTimeout(() => {
                    hideGroundPlane();
                }, 3000);

            } catch (error) {
                console.log('⚠️ Ground Plane 생성 중 오류:', error);
            }
        }

        function hideGroundPlane() {
            console.log('🔍 hideGroundPlane 함수 호출됨');

            if (groundPlaneTimeout) {
                clearTimeout(groundPlaneTimeout);
                groundPlaneTimeout = null;
            }

            if (groundPlaneElement) {
                console.log('🔍 Ground Plane 엘리먼트 제거 중...');

                // 직접 제거 (CSS 애니메이션 없이)
                if (groundPlaneElement.parentNode) {
                    groundPlaneElement.parentNode.removeChild(groundPlaneElement);
                }
                groundPlaneElement = null;

                console.log('🎯 Ground Plane 숨김 완료');
            }
        }

        // Flutter와 통신할 수 있는 인터페이스
        window.addEventListener('message', (event) => {
            console.log('🔄 HTML 메시지 수신:', event.data);

            if (event.data.type === 'startAR') {
                console.log('🚀 Flutter에서 AR 시작 요청');
                viewer.activateAR();
                sendMessageToFlutter('arButtonPressed');
            } else if (event.data.type === 'resetView') {
                console.log('🔄 뷰 리셋 요청');
                viewer.cameraOrbit = viewer.cameraOrbit; // 기본값 유지
                currentScale = 1.0;
            } else if (event.data.type === 'changeModel') {
                console.log('🎯 모델 변경 요청:', event.data.src, event.data.name);
                changeModel(event.data.src, event.data.name);
            } else if (event.data.type === 'placeModel') {
                console.log('📍 Flutter에서 모델 배치 요청:', event.data.x, event.data.y);
                if (isPlacementMode && !isModelPlaced) {
                    placeModelAtPosition(event.data.x || window.innerWidth / 2, event.data.y || window.innerHeight / 2);
                }
            } else {
                console.log('❓ 알 수 없는 메시지 타입:', event.data.type);
            }
        });

        // 개선된 모델 변경 함수 (즉시 변경 + 캐시 우선)
        function changeModel(newSrc, newName) {
            console.log('🔄 모델 변경:', newName);

            // 동일한 모델인 경우 즉시 리턴
            if (viewer.src === newSrc || viewer.src.endsWith(newSrc)) {
                console.log('⚠️ 동일한 모델이므로 변경하지 않음:', newName);
                sendMessageToFlutter('modelLoaded', { src: newSrc, name: newName });
                return;
            }

            // 로딩 상태 알림
            sendMessageToFlutter('modelLoading', { src: newSrc, name: newName });

            // 캐시된 모델 확인
            const cachedUrl = modelCache.get(newSrc);
            const finalSrc = cachedUrl || newSrc;

            if (cachedUrl) {
                console.log('⚡ 캐시된 모델 사용:', newName);
                // 캐시된 경우 즉시 로딩 완료 처리
                setTimeout(() => {
                    sendMessageToFlutter('modelLoaded', { src: newSrc, name: newName });
                }, 100);
            } else {
                console.log('🌐 네트워크에서 모델 로딩:', newName);
                // 네트워크 로딩 필요한 경우에만 load 이벤트 기다림
                viewer.addEventListener('load', () => {
                    console.log('✅ 모델 로드 완료:', newName);
                    sendMessageToFlutter('modelLoaded', { src: newSrc, name: newName });
                }, { once: true });

                // 에러 이벤트 감시
                viewer.addEventListener('error', (event) => {
                    console.error('❌ 모델 로딩 에러:', newName, event.detail);
                    sendMessageToFlutter('error', {
                        message: event.detail?.message || '모델 로딩 실패',
                        src: newSrc,
                        name: newName
                    });
                }, { once: true });
            }

            // 모델 소스 변경
            viewer.src = finalSrc;
            viewer.alt = newName + ' 3D 모델';

            // 상태 초기화
            currentScale = 1.0;
            currentRotationX = 0;
            hasRotated = false;
            hasZoomed = false;
            initialScale = 1.0;
            initialRotationX = 0;
        }
        
        // AR 버튼 제거: Flutter UI에서 처리

        // 모델 로드 완료 이벤트는 changeModel 함수 내부에서 처리됨

        // 에러 이벤트
        viewer.addEventListener('error', (event) => {
            sendMessageToFlutter('error', {
                message: event.detail?.message || '알 수 없는 오류'
            });
        });

        // AR 상태를 Flutter로 전달
        viewer.addEventListener('ar-status', (event) => {
            const status = event.detail.status;

            // Flutter로 AR 상태 전달
            sendMessageToFlutter('arStatus', { status: status });

            // 상태별 피드백 전송
            if (status === 'session-started') {
                sendMessageToFlutter('arSessionStarted');
            } else if (status === 'session-ended') {
                sendMessageToFlutter('arSessionEnded');

                // AR 세션 종료 시 상태 초기화
                console.log('🔄 AR 세션 종료 - 상태 초기화');

                viewer.style.opacity = '1';
                isPlacementMode = false;
                isModelPlaced = false;
            }
            
            // AR 세션 시작 시 터치 이동 시스템 활성화
            if (event.detail.status === 'session-started') {
                console.log('🚀 AR 세션 시작됨 - 터치 이동 시스템 활성화');

                // 초기 상태 설정
                isPlacementMode = true;
                isModelPlaced = false;
                isPlaneDetected = false;

                // 평면 감지 알림
                sendMessageToFlutter('planeDetectionChanged', { detected: false });

                setupARScaling();
                setupPlaneDetection();
                setupTouchMovement(); // 🎯 새로운 터치 이동 시스템

                // AR 렌더링 최적화 설정
                if (viewer.arSession) {
                    // 깊이 테스트 개선
                    viewer.arSession.updateRenderState({
                        depthNear: 0.1,
                        depthFar: 100
                    });

                    // 오클루전 처리 활성화 (WebXR에서 지원 시)
                    if (viewer.arSession.environmentBlendMode) {
                        console.log('환경 블렌드 모드:', viewer.arSession.environmentBlendMode);
                    }
                }
            }
        });
        
        // 배치 버튼 제거: Flutter UI에서 처리

        // 모델 배치 함수
        function placeModelAtPosition(x, y) {
            // 모델 완전히 표시
            viewer.style.opacity = '1';

            // 배치 완료 상태로 변경
            isModelPlaced = true;
            isPlacementMode = false;

            // 배치 버튼은 Flutter UI에서 처리

            // 햅틱 피드백 전송
            sendMessageToFlutter('hapticFeedback', { intensity: 'success' });

            // 배치 완료 메시지
            sendMessageToFlutter('modelPlaced', { x: x, y: y });

            console.log(`모델이 (${x}, ${y}) 위치에 배치되었습니다.`);
        }

        // 🚀 터치 기반 모델 이동 시스템
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        function setupTouchMovement() {
            console.log('🎯 터치 이동 시스템 설정 중...');

            // 모델에 드래그 피드백 CSS 클래스 추가
            viewer.classList.add('drag-feedback');

            // 터치 시작 이벤트
            viewer.addEventListener('touchstart', (event) => {
                if (isModelPlaced && event.touches.length === 1) {
                    event.preventDefault();

                    const touch = event.touches[0];
                    dragStartX = touch.clientX;
                    dragStartY = touch.clientY;
                    isDragging = true;

                    console.log('👆 모델 드래그 시작:', dragStartX, dragStartY);

                    // 드래그 시작 피드백
                    sendMessageToFlutter('hapticFeedback', { intensity: 'light' });
                }
            }, { passive: false });

            // 터치 이동 이벤트
            viewer.addEventListener('touchmove', (event) => {
                if (isDragging && event.touches.length === 1) {
                    event.preventDefault();

                    const touch = event.touches[0];
                    const deltaX = touch.clientX - dragStartX;
                    const deltaY = touch.clientY - dragStartY;

                    // 🎯 핵심: 터치 위치로 모델 이동
                    moveModelToTouchPosition(touch.clientX, touch.clientY);
                }
            }, { passive: false });

            // 터치 종료 이벤트
            viewer.addEventListener('touchend', (event) => {
                if (isDragging) {
                    isDragging = false;
                    console.log('👆 모델 드래그 완료');

                    // 모델을 원래 상태로 복원
                    viewer.style.opacity = '1';
                    viewer.style.transform = 'scale(1)';

                    // 드래그 인디케이터 제거
                    if (dragIndicator) {
                        dragIndicator.remove();
                        dragIndicator = null;
                    }

                    // 드래그 완료 피드백
                    sendMessageToFlutter('hapticFeedback', { intensity: 'medium' });
                    sendMessageToFlutter('modelMoved', {
                        message: '모델이 새 위치로 이동되었습니다'
                    });
                }
            });

            console.log('✅ 터치 이동 시스템 설정 완료');
        }

        // 터치 위치로 모델 이동하는 함수
        function moveModelToTouchPosition(touchX, touchY) {
            try {
                // 화면 좌표를 정규화된 좌표로 변환
                const normalizedX = (touchX / window.innerWidth) * 2 - 1;
                const normalizedY = -((touchY / window.innerHeight) * 2 - 1);

                console.log('🎯 터치 위치:', touchX, touchY);

                // 🎯 핵심: 시각적 피드백으로 이동 효과 구현
                // 모델을 실제로는 이동하지 않지만, 사용자에게 이동하는 느낌을 제공

                // 1. 화면 중앙에서의 거리 계산
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                const distance = Math.sqrt(
                    Math.pow(touchX - centerX, 2) + Math.pow(touchY - centerY, 2)
                );

                // 2. 거리에 따른 시각적 효과
                if (distance > 50) { // 중앙에서 50px 이상 떨어진 경우
                    // 모델 약간 투명하게 (이동 중 효과)
                    viewer.style.opacity = '0.8';
                    viewer.style.transform = 'scale(0.95)'; // 약간 작게

                    // 드래그 방향 시각화
                    createDragIndicator(touchX, touchY);
                } else {
                    // 원래 상태로 복원
                    viewer.style.opacity = '1';
                    viewer.style.transform = 'scale(1)';
                }

                // 3. Flutter에 터치 위치 정보 전송 (UI 업데이트용)
                sendMessageToFlutter('modelDragging', {
                    x: touchX,
                    y: touchY,
                    distance: distance
                });

            } catch (error) {
                console.log('⚠️ 모델 이동 중 오류:', error);
            }
        }

        // 드래그 방향 시각화 인디케이터
        let dragIndicator = null;

        function createDragIndicator(x, y) {
            // 기존 인디케이터 제거
            if (dragIndicator) {
                dragIndicator.remove();
            }

            // 새로운 드래그 인디케이터 생성
            dragIndicator = document.createElement('div');
            dragIndicator.style.position = 'absolute';
            dragIndicator.style.left = (x - 10) + 'px';
            dragIndicator.style.top = (y - 10) + 'px';
            dragIndicator.style.width = '20px';
            dragIndicator.style.height = '20px';
            dragIndicator.style.borderRadius = '50%';
            dragIndicator.style.backgroundColor = 'rgba(0, 60, 122, 0.7)';
            dragIndicator.style.border = '2px solid white';
            dragIndicator.style.pointerEvents = 'none';
            dragIndicator.style.zIndex = '1000';
            dragIndicator.style.animation = 'pulse 0.5s ease-in-out infinite alternate';

            document.body.appendChild(dragIndicator);

            // 0.5초 후 자동 제거
            setTimeout(() => {
                if (dragIndicator) {
                    dragIndicator.remove();
                    dragIndicator = null;
                }
            }, 500);
        }

        // 평면 감지 설정
        function setupPlaneDetection() {
            if (!viewer.arSession) {
                console.log('⚠️ AR 세션이 없어서 평면 감지를 설정할 수 없습니다');
                return;
            }

            console.log('🔍 평면 감지 설정 시작');

            // 정기적으로 평면 감지 상태 확인
            const planeDetectionInterval = setInterval(() => {
                if (!isPlacementMode || isModelPlaced) {
                    clearInterval(planeDetectionInterval);
                    return;
                }

                checkForPlanes();
            }, 500); // 0.5초마다 확인
        }

        // 평면 확인 함수
        function checkForPlanes() {
            if (!viewer.arSession) return;

            // WebXR에서 평면 감지 확인 (실제로는 복잡하지만 간단한 근사치 사용)
            const frame = viewer.arSession.requestAnimationFrame ? viewer.arSession.requestAnimationFrame() : null;

            // 실제 평면 감지는 복잡하므로, 간단한 timeout 기반 시뮬레이션 사용
            // 실제 구현에서는 hit-test API를 사용해야 함
            setTimeout(() => {
                // 3초 후 평면이 감지된 것으로 시뮬레이션
                if (isPlacementMode && !isModelPlaced && !isPlaneDetected) {
                    console.log('✅ 평면 감지됨');
                    isPlaneDetected = true;
                    sendMessageToFlutter('planeDetectionChanged', {
                        detected: true,
                        message: '평면이 감지되었습니다. 원하는 위치에 배치하세요.'
                    });
                }
            }, 3000);
        }

        // AR 모드에서 스케일 및 회전 설정
        function setupARScaling() {
            // WebXR 세션에서 스케일 이벤트 처리
            if (viewer.arSession) {
                // 터치 이벤트로 직접 스케일 처리
                viewer.addEventListener('touchstart', handleTouchStart, { passive: false });
                viewer.addEventListener('touchmove', handleTouchMove, { passive: false });
                viewer.addEventListener('touchend', handleTouchEnd, { passive: false });
            }
        }
        
        // 회전 관련 변수
        let isRotating = false;
        let lastTouchY = 0;
        let currentRotationX = 0;

        // 제스처 힌트 추적 변수
        let hasRotated = false;
        let hasZoomed = false;
        let rotationThreshold = 20; // 20도 이상 회전 시 완료로 간주
        let zoomThreshold = 0.2; // 20% 이상 스케일 변경 시 완료로 간주
        let initialScale = 1.0;
        let initialRotationX = 0;
        
        // 터치 시작
        function handleTouchStart(e) {
            // 터치 포인트에 시각적 피드백
            const touch = e.touches[0];
            createModelHighlight(touch.clientX, touch.clientY);

            // 🎯 터치 시 Ground Plane 표시 (테스트용 - AR 체크 제거)
            console.log('🔍 터치 이벤트 발생, Ground Plane 호출');
            showGroundPlane();

            // Flutter로 모델 터치 알림
            sendMessageToFlutter('modelTouched', {
                x: touch.clientX,
                y: touch.clientY
            });

            if (e.touches.length === 1) {
                // 한 손가락 터치 - 회전 시작
                isRotating = true;
                lastTouchY = e.touches[0].clientY;

                // 제스처 시작 알림
                sendMessageToFlutter('gestureStart', { type: 'rotate' });

                // 초기 회전값 저장
                if (!hasRotated) {
                    initialRotationX = currentRotationX;
                }
            } else if (e.touches.length === 2) {
                // 두 손가락 터치 - 핀치 시작
                isRotating = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                lastTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );

                // 제스처 시작 알림
                sendMessageToFlutter('gestureStart', { type: 'pinch' });

                // 초기 스케일값 저장
                if (!hasZoomed) {
                    initialScale = currentScale;
                }
            }
        }
        
        // 터치 이동
        function handleTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 1 && isRotating) {
                // 한 손가락 드래그 - X축 회전만
                const deltaY = e.touches[0].clientY - lastTouchY;
                
                // X축 회전 (상하 드래그) - 제한 적용
                currentRotationX -= deltaY * 0.5; // 위로 드래그하면 위로 회전
                currentRotationX = Math.max(-60, Math.min(60, currentRotationX)); // -60도 ~ +60도
                
                // 모델에 회전 적용
                if (viewer.model) {
                    const model = viewer.model;
                    model.rotation = `${currentRotationX}deg 0deg 0deg`;
                }

                lastTouchY = e.touches[0].clientY;

                // 회전 제스처 완료 체크
                if (!hasRotated && Math.abs(currentRotationX - initialRotationX) >= rotationThreshold) {
                    hasRotated = true;
                    sendMessageToFlutter('rotation', {
                        totalRotation: Math.abs(currentRotationX - initialRotationX)
                    });
                }
                
            } else if (e.touches.length === 2 && !isRotating) {
                // 두 손가락 핀치 - 스케일 조절
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                if (lastTouchDistance > 0) {
                    const scaleDelta = currentDistance / lastTouchDistance;
                    currentScale *= scaleDelta;
                    currentScale = Math.max(0.1, Math.min(5.0, currentScale)); // 10% ~ 500% 제한
                    
                    // 모델 스케일 적용
                    if (viewer.model) {
                        viewer.model.scale = `${currentScale} ${currentScale} ${currentScale}`;
                    }
                }

                lastTouchDistance = currentDistance;

                // 확대/축소 제스처 완료 체크
                if (!hasZoomed && Math.abs(currentScale - initialScale) >= zoomThreshold) {
                    hasZoomed = true;
                    sendMessageToFlutter('zoom', {
                        totalScaleChange: Math.abs(currentScale - initialScale),
                        finalScale: currentScale
                    });
                }
            }
        }
        
        // 터치 종료
        function handleTouchEnd(e) {
            if (e.touches.length < 2) {
                lastTouchDistance = 0;
                // 스케일 및 회전 값 유지 (원상복귀하지 않음)
                console.log('현재 스케일:', currentScale, 'X축 회전:', currentRotationX);

                // 제스처 종료 알림
                sendMessageToFlutter('gestureEnd', {
                    scale: currentScale,
                    rotation: currentRotationX
                });
            }
            if (e.touches.length === 0) {
                isRotating = false;
            }
        }
        
        // 3D 뷰어 모드에서도 스케일 유지
        viewer.addEventListener('camera-change', (event) => {
            // 카메라 변경 시에도 스케일 유지
            if (!viewer.arSession && currentScale !== 1.0) {
                viewer.scale = `${currentScale} ${currentScale} ${currentScale}`;
            }
        });

        // 추가 Model Viewer 이벤트들
        viewer.addEventListener('interaction-prompt', (event) => {
            sendMessageToFlutter('interactionPrompt', {
                status: event.detail.visible
            });
        });

        viewer.addEventListener('play', (event) => {
            sendMessageToFlutter('animationPlay');
        });

        viewer.addEventListener('pause', (event) => {
            sendMessageToFlutter('animationPause');
        });

        // Flutter 오버레이 방식으로 변경 - 복잡한 터치 차단 로직 제거됨

        // 간단한 터치 리플 효과 (Flutter 오버레이와 충돌 없음)
        document.addEventListener('touchstart', (event) => {
            const viewerRect = viewer.getBoundingClientRect();
            const touch = event.touches[0];

            if (touch.clientX >= viewerRect.left &&
                touch.clientX <= viewerRect.right &&
                touch.clientY >= viewerRect.top &&
                touch.clientY <= viewerRect.bottom) {
                createTouchRipple(touch.clientX, touch.clientY);
            }
        }, { passive: true });

        // 초기화 완료 알림
        window.addEventListener('load', () => {
            sendMessageToFlutter('htmlLoaded');
            console.log('Model Viewer HTML 로딩 완료');

            // 🔍 테스트: 페이지 로드 3초 후 Ground Plane 표시
            setTimeout(() => {
                console.log('🧪 테스트: 자동으로 Ground Plane 표시 시도');
                showGroundPlane();
            }, 3000);
        });
    </script>
</body>
</html>